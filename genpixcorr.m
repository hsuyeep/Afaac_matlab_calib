% Script to carry out pixel level correlations between generated images.
% The resulting correlation function gives information on :
%	- The independence of time sampled images, useful for constraining 
%	  transient rates.
%	- The confusion noise limit, both for classical and Sidelobe confusion.
% Arguments:
%	fimg     :  Image timeseries binary filename, as generated by genfftimage.m etc.
%               OR a folder containing fits images, now ingested by readfitsfile.m
%	start_rec:  Record offset in file to beginning of timeseries.
%	skip     :  Number of records to skip in generating the time series.
%	nrecs	 :  Number of records in analysis timeseries
%	thresh   :  Sigma cutoff for noise estimation.
%	region	 :  [center, radius], region of the image on which to operate, in l,m units.
%      deb   :  Debug flag, set to 1 for intermediate results.

function [acf_pix, spatial_corr, timg] = genpixcorr (fimg, start_rec, skip, nrecs, thresh, region, deb)
	% Check if parameters are valid
	assert (isempty (fimg) == 0);

    % Check if images are matlab or fits files.
    if (2 == exist (fimg)) % Single file => .bin image files.
        readimg = @readimg2bin;
        binfile = 1;
    elseif (7 == exist (fimg)) % Is a folder, expect .fits files within 
        fitsfiles = dir ([fimg '/*.fits']); % fitsfiles is 
        fprintf (2, '<-- Found %d fits files.\n', length(fitsfiles));
        readimg = @readfitsimage;
        binfile = 0;
    else
        fprintf (2, '### Path does not exist!\n');
        return;
    end; 

	if (isempty (start_rec)) start_rec = 1; end;

    % NOTE: The skip parameter for fits files will skip time (=files) in order of appearance.
	if (isempty (skip)) skip = 1; end; 
	if (isempty (thresh)) thresh = 3; end; % Default sigma for cutoff.
	if (isempty (nrecs)) nrecs = 400; end; % Default timeseries, assuming 1sec. images.
    if (isempty (region) | region.radius < 0 | region.radius > 1) region.radius = 0.5; end; % In l/m units.

	% Display information from file.
    if (binfile)
		fprintf (1, '<-- Operating on file %s.\n', fimg);
		fid = fopen (fimg, 'r');
		img = readimg2bin (fid, 0); 
    else
		fprintf (1, '<-- Operating on file %s.\n', fitsfiles(1).name);
        img = readfitsimage ([fimg, '/',  fitsfiles(1).name], 0);
    end;

	fprintf (1, '<-- Image timeseries start : %s, freq: %f.\n', datestr(mjdsec2datenum (img.tobs)), img.freq);
	fprintf (1, '<-- %04dx%04d image, l range : [%.3f, %.3f], m range : [%.3f, %.3f]\n', img.pix2laxis, img.pix2maxis, min(img.l), max(img.l), min(img.m), max(img.m));

    fprintf (1, '<-- Process params: thresh: %d, nrecs: %d, region.radius: %d\n', thresh, nrecs, region.radius);
	fprintf (1, '<-- Generating desired mask...\n');
	mask = ones (img.pix2laxis, img.pix2maxis);

	[l, m] = meshgrid (img.l, img.m);
	% Generate mask for the specified region, ignoring offset of the center for now.
	mask (l.^2 + m.^2 > region.radius) = 0;

	% Create data structure for storing timeseries of valid pixels.
    fprintf (1, '<-- Pixels in selected region: %d\n', sum(mask(:)));
	pixtseries = zeros (nrecs, sum(mask(:)));
    timg =zeros (nrecs); % To store image times.


	for imgind = 1:nrecs
        fprintf (1, '<-- Collecting image %04d, %s\n', imgind, datestr(mjdsec2datenum(img.tobs)));
		
		% Apply sigma clipping on the masked region, eliminate bright pixels.
		valpix = img.map (mask == 1);
		[mu, v, sel] = robustmean (valpix, thresh);

		% Set the unused pixels to 0s, so that a consistent matrix can be used.
		valpix (sel == 0) = 0;  %NOTE: 0 values, should ideally be NaNs...

		% store valid pixels
		pixtseries (imgind, :) = valpix;
        timg (imgind) = img.tobs;

        % Read in the next image
        if (binfile)
        	img = readimg2bin (fid, 0); 
        else
            img = readfitsimage ([fimg, '/',  fitsfiles(imgind).name], 0);
        end;
	end;

    % Carry out a mean subtraction to make each timeseries 0-mean.
    % NOTE: mean calculation does not exclude 0-pixels yet!
    pixtseries = pixtseries - repmat (mean (pixtseries), [nrecs, 1]);

    if (deb == 1)
        % Show the contents of the valid pixels
        tmpimg = zeros (size(img.map));
        for ind = 1:nrecs
            tmpimg (mask == 1) = pixtseries(ind, :);
            clf ();
            subplot (211);
            imagesc (img.l, img.m, tmpimg); colorbar();
            title (sprintf ('Time: %s', datestr(mjdsec2datenum(timg(ind)))));
            subplot (212);
            hist (pixtseries(ind,:), 50);
            pause(0.1);
        end;
    end;

	% 1. Temporal correlation of every pixel: Generate the Auto Correlation Function
	%	 of the timeseries of each pixel. Note, the timeseries is stored in a column.
    fprintf (1, '<-- Calculating temporal correlation...\n');
	Pix = fft(pixtseries,2*nrecs-1); % FFT carried out independently per column
	acf_pix = fftshift (ifft(Pix.*conj(Pix)),1);
    scale_fact = sum(pixtseries.^2);
    acf_pix = acf_pix ./ repmat (scale_fact, [2*nrecs-1, 1]);
	% acf_pix = acf_pix ./ repmat (max(acf_pix), 2*nrecs-1, 1); % Normalize corr. coef. to 1.

    % 2. Spatial correlation over all pixels in chosen field of view, assuming the
    % noise is uniform over the field of view.
    % Transpose because corrcoef requires the random variables in each col, with
    % its observations in each row. Here, each row of pixtseries contains all 
    % pixels from a file (timestamp), so is counted as multiple instances of the
    % noise variable.
    fprintf (1, '<-- Calculating spatial correlation...\n');
    spatial_corr = corrcoef (pixtseries');

    % Plot correlation function over lag, both of a single pixel, and an average of all pixels
    % plot (timg-timg(1), acf_pix (:,23000), '.');
