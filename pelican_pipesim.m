% Program to simulate a pelican pipeline, using the pelican_sunAteamSub.m
% and fft_imager_sjw () functions.
% Arguments:
%    fname    : Name of binary file containing a single ACM per timeslice,
%               with freq. information. File as generated by readms2float.py
%				from a MeasurementSet.
%    ntslices : The number of timeslices to process.
%    filestore: Bool enabling storing of relevant variables per timeslice
%               to file or not.
% pep/23Mar12

function pelican_pipesim (fname, ntslices, filestore)
    Nelem = 288; 
    nblines = Nelem * (Nelem + 1)/2; 
    uvflag = eye (288); % Flag only the autocorrelations
    freq = 59756469;    % Initialization, actual freq. is part of bin file.
    mins2cal = 2;       % Time interval of calib. sliding window.
    debuglev = 2;       % Control of level of debug messages.
    % flagant = [6, 103]; % Antennas to flag, before carrying out calibration
    flagant = [1:12, 51, 206]; % Antennas to flag, before carrying out calibration
    ptSun = 0;          % Use point source model of the Sun
    radec = 0;          % Not create RA/Dec images
    skiprecs = 91;      % Initial number of records to skip.
	% Record size in bytes, 2 doubles (time/freq), followed by a complex float 
	% array of visibilities, 288*289/2.
	recsize = (4 + 288*289)*4; 

    % FFT Imaging related
    % duv = 600/511;                % In meters, grid spacing in fft imager
    duv = 2.5;
    Nuv = 500; %1000                % size of gridded visibility matrix
    uvpad = 512; %1024              % specifies if any padding needs to be added

    calmap_prev = zeros (uvpad, uvpad);
    diffimg = calmap_prev;

    % Local horizon based coordinates of array in ITRF
    load ('poslocal.mat', 'posITRF', 'poslocal'); 

    % Generate uv coordinates in local horizon coord. system, needed for imaging
    uloc = meshgrid (poslocal(:,1)) - meshgrid (poslocal (:,1)).';
    vloc = meshgrid (poslocal(:,2)) - meshgrid (poslocal (:,2)).';

	% Generate flagged uv coords.
    [uloc_flag, vloc_flag] = gen_flagged_uvloc (uloc, vloc, flagant); 

    % normal to CS002 field (ITRF)
    normal = [0.598753, 0.072099, 0.797682].'; 

	% Open raw data from a .bin file. NOTE: No check for file validity!
    fid = fopen (fname, 'rb');
    if (filestore == 1)
      outfilename = strrep (fname, '.bin', '_pelpipe.mat');
      badcalfilename = strrep (fname, '.bin', '_pelpipe_badcal.mat');    
      disp(['Writing cal solutions to file: ' outfilename ... 
		    'Badcalsol to file: ' badcalfilename]);
    else
       disp (['Displaying calibrated images.']);
       figure; % If not writing to file, display images.
    end

	% Read in a record.
    [acc, t_obs, freq] = readms2float (fid, -1, -1);
    disp (['Timeslice: ' num2str(t_obs, '%f') ... 
		  ' (MJD secs) for initial estimation']);
	% Read in another record to determine the integration time.
    [acc, t_obs1, freq] = readms2float (fid, -1, -1);

	% recalibrate every 2 mins 
    tslices2cal = floor ((mins2cal*60)/(t_obs1 - t_obs)); 
    disp (['Time resolution of observations: ' num2str(t_obs1 - t_obs) ...
		  ' secs']);
    disp (['Calibrating every ' num2str(tslices2cal) ' timeslices']);
    
    % Convert MJD secs. to Julian day.
    t_obs  = t_obs/86400 + 2400000.5; 
    t_obs1 = t_obs1/86400 + 2400000.5;
   
    % Go to the beginning of the file, read out one timeslice
    fseek (fid, 0, -1);
    [acc, t_obs, freq] = readms2float (fid, -1, -1);
    if (isempty (t_obs) || isempty(acc))
       return;
    end

	% Calibrate currentl timeslice.
    % [calvis, gainsol, sigmas, sigman, good] = ... 
	% 								pelican_calib (acc, t_obs, freq, uvflag);

    [thsrc_cat, phisrc_cat, thsrc_wsf, phisrc_wsf, suncomps, calvis, gainsol,...
					sigmas, sigman, good] = ... 
	pelican_sunAteamsub (acc, t_obs, freq, uvflag, flagant, debuglev, ptSun);

	% Image current timeslice.
    [radecmap, calmap, calvis] = ... 
		fft_imager_sjw_radec (calvis (:), uloc_flag(:), vloc_flag(:), ... 
								duv, Nuv, uvpad, t_obs, freq, radec);

 	% Record relevant parameters to disk, if required.
    if (filestore == 1)
        t_obs_store (1) = t_obs;
        cal_store (:,1) = gainsol;
        sigmas_store    = {};
        sigmas_store{1} = sigmas;
        sigman_store(:,:,1) = sigman;
        image_store (:,:,1) = calmap; 

        badt_obs_store (1) = t_obs;
        badcal_store (:,1) = gainsol;
        badsigmas_store    = {};
        badsigmas_store{1} = sigmas;
        badsigman_store(:,:,1) = sigman;
        badimage_store (:,:,1) = calmap; 
        badcalrun = 1;
    else
		imagesc (real(calmap));
		colorbar ();
		title (['Timeslice: 0, (MJD): ' num2str(t_obs) 'Freq: ' ...
				num2str(freq, '%f')]);
		pause (1);
    end
        % Quality of calibration solutions, as determined by the phase solutions
%     for station=1:6
%         ph_var (station) = var (angle(gainsol (1+(station-1)*48:station*48)));
%     end
%     if sum(ph_var > 1) ~= 0 
%         good_cal (1) = false;
%     else
%         good_cal (1) = true;
%     end 
    t = 1;
    calrun = 1;
    stop_processing = 0 ;

    %%
    offset = skiprecs*recsize;
    fseek (fid, offset, -1);
    
   try
        % while (feof (fid) ~= 1 & stop_processing == 0)
        for i=1:ntslices
%%
            t = t + 1;
            [acc, t_obs, freq] = readms2float (fid, -1, -1);
            if (isempty (t_obs))
                break;
            end
            disp ('---->');
            disp (['Timeslice: ' num2str(t) ' (' num2str(t_obs, '%f') ',' ... 
				  num2str(freq) ')']);

            if (isempty(acc))
                break;
            end
            calrun = calrun + 1;           
            
            % Calibrate this timeslice
            % [calvis, gainsol, sigmas, sigman, good] =  ... 
		    %						pelican_calib (acc, t_obs, freq, uvflag);
            % [calvis, gainsol, sigmas, sigman, good] = ... 
			%			pelican_sunAteamsub (acc, t_obs, freq, uvflag, posITRF);

            [thsrc_cat, phisrc_cat, thsrc_wsf, phisrc_wsf, suncomps,...
						 calvis, gainsol, sigmas, sigman, good] = ...
							pelican_sunAteamsub (acc, t_obs, freq, uvflag, ...
												 flagant, debuglev, ptSun);
            sunwsfpos = [phisrc_wsf(end), thsrc_wsf(end)]
            
            % Quality of calib. solutions, as determined by the phase solutions
			% for station=1:6
			% 	ph_var (station) =  ...
			%			var (angle(gainsol (1+(station-1)*48:station*48)));
            % end

            % Image this data
            [radecmap, calmap, calvis] =  ...
					fft_imager_sjw_radec (calvis (:), uloc_flag(:), ...
						 vloc_flag(:), duv, Nuv, uvpad, t_obs, freq, radec); 
            % [calmap, ~] = fft_imager (calvis, uloc, vloc, duv, Nuv, uvpad);
            if (filestore == 1)           
                t_obs_store (calrun) = t_obs;           
                cal_store (:,calrun) = gainsol;
                sigmas_store {calrun} = sigmas;
                sigman_store (:,:,calrun) = sigman;            
                image_store (:,:,calrun) = calmap;
		    else
				imagesc (real(calmap));
				colorbar ();
				title (['Timeslice: ' num2str(i) ', (MJD): ' num2str(t_obs) ...
						'Freq: ' num2str(freq, '%f')]);
				% pause (1);
            end

			% Generate difference images
			% diffimg = imgdiff (calmap, calmap_prev, t_obs, freq);
  		    diffimg = calmap - calmap_prev;
            calmap_prev = calmap;
			diff_fname = sprintf ('%8.0f_%10.0f_diff.mat', freq, t_obs);
			save (diff_fname, 't_obs', 'freq', 'diffimg', 'calmap', ... 
				  'suncomps', 'phisrc_wsf', 'thsrc_wsf');

%           if sum(ph_var > 1) ~= 0 
%           	good_cal (calrun) = false;
%           	disp ('CALIBRATION SOLUTION DETERMINED TO BE BAD!!')
%           	disp ('Storing to badcal file!');
%           	badcalrun = badcalrun + 1;            
%           	badt_obs_store (badcalrun) = t_obs;           
%           	badcal_store (:,badcalrun) = gainsol;
%           	badsigmas_store {badcalrun} = sigmas;
%           	badsigman_store (:,:,calrun) = sigman;            
%           	badimage_store (:,:,calrun) = calmap;
%           else
%           	good_cal (calrun) = true;
%           	disp ('Good calibration solution found');
%           end 

            
%            for t_ind = 1:tslices2cal
%                t_obs = fread (fid, 1, 'double');
%                a = fread (fid, 2*nblines, 'float'); % Read one ccm worth
%            end    
        end
    catch err
    	disp ('Error encountered! Saving variables to disk..');
    	if (filestore == 1)
    		save (outfilename, 'cal_store', 'sigmas_store', 'sigman_store',  ...
							   't_obs_store', 'image_store', 'good_cal');
			save (badcalfilename, 'badcal_store', 'badsigmas_store', ... 
								  'badsigman_store', 'badt_obs_store', ... 
								  'badimage_store', 'badgood_cal');
    	end
    	    rethrow (err);
    end
    disp ('Calibration check completed. Storing variables to file');

    if (filestore == 1)    
        save (outfilename, 'cal_store', 'sigmas_store', 'sigman_store', ... 
						   't_obs_store', 'image_store', 'good_cal');
        save (badcalfilename, 'badcal_store', 'badsigmas_store', ... 
							  'badsigman_store', 'badt_obs_store', ...
							  'badimage_store', 'badgood_cal');
    end
