% Script to generate image difference noise statistics
% Takes image domain differences, in time, using the timeseries of calibrated
% visibilities generated by wrcalvis2bin.m
%    NOTE: if t0-tn is the timeseries of raw images, a diffimage timeseries with
% a difference parameter of m is:
%  sig(n=m+1:n)ti - sig(n=0:m)ti, and NOT:
% (t1-t0), (t2-t1), (t3-t2)... (tn-tn-1), as on integration, this becomes:
% (tn-tn-1+tn-1-tn-2+... t1-t0) = (tn-t0), so an N sample integrated difference
% time series is actually only a two sample difference!
% and also not:
% (t1-t0), (t3-t2), (t5-t4) ... (tn-tn-1), as on integration, this becomes:
% (t1+t3+t5...tn-1) - (t0+t2+t4+...tn)
% pep/20Jun13
% Arguments:
%	fname : Filename of the binary file containing the calibrated visibilities.
% posfname: Filename of the array configuration matrix, for imaging.
% ntslices: Number of timeslices on which to generate the temporal statistics.
% winsize : Split the total timeslices into winsize blocks. This allows looking
%			at long term statistics using windows of size winsize timeslices.
%			NOTE: CURRENTLY UNIMPLEMENTED.
% offset  : Number of records to skip in this file, before starting analysis.
% noisereg: [xbl, ybl, pix] region in pixel units over which noise statistics 
%			are computed. The region has a top left corner of (xbl,ybl), and is 
%			a square of side 'pix' pixels.

function func_diffimg (fname, posfname, offset, ntslices, winsize, noisereg)

	% Imaging parameters
    duv = 2.5;						% Default, reassigned from freq. of obs. to
									% image just the full Fov (-1<l<1)
    Nuv = 500; %1000                % size of gridded visibility matrix
    uvpad = 512; %1024              % specifies if any padding needs to be added


	thresh = 2;						% Sigma threshold to detect outlier pixels.
	if ntslices == -1
		[ntslices, tmin, tmax, dt] = getnrecs (fname);
		fprintf (1, 'Found %d timeslices at %f sec. resolution.\n', ...
				 ntslices, dt);
	end;

	tblks = int32(ntslices/winsize);% Time windows over which to generate stats.
	rawmap = zeros (uvpad, uvpad, winsize);

	rawmean = zeros (1, winsize/2);
	rawstd  = zeros (1, winsize/2);
	diffmean = zeros (1, winsize/2);
	diffstd  = zeros (1, winsize/2);

%	sigtseries  = meantseries;
%	meanmaptseries = zeros (1, winsize);
%	sigmaptseries  = meantseries;
%	cumulmapmean   = zeros (1, winsize);
%	cumulmapvar    = zeros (1, winsize);
%	cumuldiffmean  = zeros (1, winsize);
%	cumuldiffvar   = zeros (1, winsize);

	fid = fopen (fname, 'rb');

	load (posfname, 'poslocal');
    uloc = meshgrid (poslocal(:,1)) - meshgrid (poslocal (:,1)).';
    vloc = meshgrid (poslocal(:,2)) - meshgrid (poslocal (:,2)).';
    wloc = meshgrid (poslocal(:,3)) - meshgrid (poslocal (:,3)).';

	% Move to desired file offset.
	if offset > 0
		[acc, tobs_first, freq] = readms2float (fid, offset, -1, 288);
	end;

	% Read in a calibrated ACM.
	[acc, img.tobs, img.freq] = readms2float (fid, -1, -1, 288);
	Nelem = size (acc, 1);

	lambda = 299792458/img.freq; 		% in m.
	% duv = lambda/2;
	% dimensionless, in dir. cos. units
    dl = (299792458/(img.freq * uvpad * duv)); 
    
    % NOTE: Total imaged Field of View is determined by the visibility 
	% grid-spacing, duv.
    lmax = dl * uvpad / 2;

	if (isempty (noisereg) == 1)
		% Default region for noise analysis is the inner quarter.
		xbl = 3*uvpad/8; ybl = 3*uvpad/8;
		xtr = 5*uvpad/8; ytr = 5*uvpad/8;
	else
		xbl = noisereg (1); ybl = noisereg(2);
		xtr = xbl + noisereg(3); ytr = ybl + noisereg(3);
	end;
	fprintf (1, 'Noise region: [bl:(%3d, %3d), tr: (%3d, %3d)]\n',  ...
			 xbl, ybl, xtr, ytr);

	% Generate the first image.
   	[radecmap, prevmap, calvis, img.l, img.m] = ... 
	  fft_imager_sjw_radec (acc(:), uloc(:), vloc(:), ... 
				duv, Nuv, uvpad, img.tobs, img.freq, 0);

	% Data structure for difference images
	diffimg  = zeros (uvpad, uvpad, winsize/2); % Holds actual img differences
	diffmap  = zeros (uvpad);
	sigdiff  = zeros (uvpad);    % Sum of x in the diff. image
	sigdiff2 = zeros (uvpad);    % Sum of x^2 in the diff. image
	mapsigdiff  = zeros (uvpad); % Sum of x in the raw image
	mapsigdiff2 = zeros (uvpad); % Sum of x^2 in the raw image

	mask = ones (uvpad);         % Mask generation, currently only for display
	mask (xbl:xtr, ybl) = 0;
	mask (xbl:xtr, ytr) = 0;
	mask (xbl, ybl:ytr) = 0;
	mask (xtr, ybl:ytr) = 0;
	
	% Single snapshot noise measurement
	mapnoisereg = prevmap (xbl:xtr, ybl:ytr);
	mmap = mean (mapnoisereg(:));
	vmap = std (mapnoisereg(:));
	imagesc ([xbl:xtr], [ybl:ytr], mapnoisereg); colorbar;
	title ('Chosen region for noise analysis within image');
	xlabel ('X-Pixel'); ylabel ('Y-Pixel');

	% Figure management
	diffhdl = figure;
	maphdl = figure;
	set(0,'Units','pixels') 
	scnsize = get(0,'ScreenSize');
	position = get(diffhdl,'Position');
	outerpos = get(diffhdl,'OuterPosition');
	borders = outerpos - position;
	edge = -borders(1)/2;
	% pos = [left bottom width height]
	pos1 = [edge, scnsize(4) * (1/2), scnsize(3)- edge, scnsize(4)/2];
	set(diffhdl,'OuterPosition',pos1);
	pos1 = [edge, 0, scnsize(3)- edge, scnsize(4)/2];
	set(maphdl,'OuterPosition',pos1);

	% Create all raw images. we iterate over these raw images to create 
	% difference images at various integration times.
	for im=1:winsize
		% Get next ACM timeslice.
		[acc, img.tobs, img.freq] = readms2float (fid, -1, 0, 288);

		% Generate image and difference image.
   		[radecmap, rawmap(:,:,im), calvis, img.l, img.m] = ... 
		  fft_imager_sjw_radec (acc(:), uloc(:), vloc(:), ... 
					duv, Nuv, uvpad, img.tobs, img.freq, 0);
		fprintf (1, 'Creating image %d at time %.2f\n', im, img.tobs);

%		mapsigdiff = mapsigdiff + rawmap (:,:,im);
%		mapsigdiff2 = mapsigdiff2 + rawmap (:,:,im).^2;
	end;

	% Create 1-second difference maps, also generate raw and diff. image 
	% instantaneous statistics and cumulative maps.
	for im=1:2:winsize
		% diffmap = (real(rawmap(:,:,im+1)) - real(rawmap (:,:,im)))/2;
		diffmap = (real(rawmap(:,:,im+1)) - real(rawmap (:,:,im)));
		% intmap  = (real(rawmap(:,:,im+1)) + real(rawmap (:,:,im)))/2;
		intmap  = (real(rawmap(:,:,im+1)) + real(rawmap (:,:,im)));

		% Generate spatial noise stats over selected region, within the snapshot
		% diff image noise
		noisemap = diffmap (xbl:xtr, ybl:ytr);
		meantseries ((im+1)/2) = mean (noisemap(:)); 
		sigtseries  ((im+1)/2) = std  (noisemap(:));
		% raw image noise
		mapnoisereg = intmap (xbl:xtr, ybl:ytr);
		meanmaptseries ((im+1)/2) = mean (mapnoisereg(:));
		sigmaptseries  ((im+1)/2) = std  (mapnoisereg(:));

		sigdiff  = sigdiff  + diffmap;
		sigdiff2 = sigdiff2 + diffmap.^2;
		mapsigdiff = mapsigdiff + intmap;
		mapsigdiff2 = mapsigdiff2 + intmap.^2;

		% Show instantaneous image, and histogram of chosen region
		figure (maphdl);
		tmpreg = intmap (xbl:xtr, ybl:ytr); % The mean diff image.
		subplot (121); imagesc (intmap); colorbar;
		subplot (122); hist (tmpreg(:), 50);

		figure (diffhdl);
		tmpreg = diffmap (xbl:xtr, ybl:ytr); % The mean diff image.
		subplot (121); imagesc (diffmap); colorbar;
		subplot (122); hist (tmpreg(:), 50);
	end;
	% Generate labels for the RT-plots
	figure (diffhdl); 
	subplot (121); xlabel ('X-Pixel'); ylabel ('Y-Pixel');
	title ('1-timeslice difference image');
	subplot (122); xlabel ('Pixel value'); ylabel ('Counts');
	title ('Noise region pixel histogram');
	figure (maphdl); 
	subplot (121); xlabel ('X-Pixel'); ylabel ('Y-Pixel');
	title ('2-timeslice integrated map');
	subplot (122); xlabel ('Pixel value'); ylabel ('Counts');
	title ('Noise region pixel histogram');

	% Plot mean and variance timeseries over this window for both diff and raw 
	% maps.
	figure;
	subplot (221);
	plot (meanmaptseries, '*r'); grid;
	xlabel ('Timeslice pairs'); ylabel ('Pixel value');
	title (sprintf ('Mean RAW image noise in chosen region, over %d timeslices', ...
					 winsize));
	subplot (222);
	plot (sigmaptseries, '*r'); grid;
	xlabel ('Timeslice pairs'); ylabel ('Pixel value');
	title (sprintf ('RAW noise std in chosen region, over %d timeslices', winsize));
	subplot (223);
	plot (meantseries, '*b'); grid;
	xlabel ('Timeslice pairs'); ylabel ('Pixel value');
	title (sprintf ('Mean DIFF image noise in chosen region, over %d timeslices', ...
					winsize));
	subplot (224);
	plot (sigtseries, '*b'); grid;
	xlabel ('Timeslice pairs'); ylabel ('Pixel value');
	title (sprintf ('DIFF image noise std in chosen region, over %d timeslices', ...
					 winsize));
	
	% Generate per pixel noise stats across time.
	% mean per pixel.
	meanperpix = sigdiff/(winsize/2);
	sigperpix  = sqrt (sigdiff2/(winsize/2) - meanperpix.^2);
	mapmeanperpix = mapsigdiff/(winsize/2);
	mapsigperpix  = sqrt (mapsigdiff2/(winsize/2) - mapmeanperpix.^2);
	

	% Generate all integrated maps possible within winsize
	for integ=1:winsize/2
		integ1 = zeros(uvpad, uvpad);
		integ2 = integ1;
		% Generate integrated images for differencing
		fprintf (2, 'NOTE: Taking only the first 2 consecutive integrated maps for differencing!\n');
		for im=1:integ
			integ1 = integ1 + real (rawmap (:,:,im));
			integ2 = integ2 + real (rawmap (:,:,im+integ));
		end;	
		% diffimg (:,:,integ) = (integ2 - integ1)/(2*integ);
		% NOTE: Difference pixel values are not divided by 2!
		diffimg (:,:,integ) = (integ2 - integ1)/integ;
		fprintf (1, 'Creating diff between 2 images integrated to %d sec\n',...
				 integ);

		% Store noise in selected region in diff and integ. images
		% NOTE: Mean images are generated by dividing by 2!
		final_integ_img = (integ1 + integ2 )/(integ);
		tmpreg = final_integ_img (xbl:xtr, ybl:ytr); % The mean cumul image.
		rawmean (integ) = mean (tmpreg(:));
		rawstd  (integ) = std  (tmpreg(:));

		tmpreg = diffimg (xbl:xtr, ybl:ytr, integ); % The mean diff image.
		diffmean(integ) = mean (tmpreg(:));
		diffstd (integ) = std  (tmpreg(:));
	end;

	% Generate noise histograms in 30-sec differences and integrated images.
	figure;
	subplot (121);
	tmpreg = final_integ_img (xbl:xtr, ybl:ytr); % The integrated image.
	hist (tmpreg(:), 50);
	title ('Hist of noise region in 60-sec integrated images');
	xlabel ('Pixel value'); ylabel ('Count');
	subplot (122);
	tmpreg = diffimg (xbl:xtr, ybl:ytr, winsize/2); % The mean diff image.
	hist (tmpreg(:), 50);
	title ('Hist of noise region in difference of 2, 30sec integrated images');
	xlabel ('Pixel value'); ylabel ('Count');

	% Generate a plot of the std. of the noise in the integrated raw and
	% difference images
	% Plot noise variance as a function of integration of both RAW and DIFF
	% images.
	figure;
	subplot (221);
	plot (rawmean, 'r*'); grid;
	xlabel ('Integrated time (secs)'); ylabel ('Mean pixel value');
	title ('Raw image noise mean at diff time integrations');
	subplot (222);
	plot (rawstd, 'r*'); grid;
	xlabel ('Integrated time (secs)'); ylabel ('std. pixel value');
	title ('Raw image std. at different time integrations');
	subplot (223); grid;
	plot (diffmean, 'b*'); grid;
	xlabel ('Integrated time (secs)'); ylabel ('Mean pixel value');
	title ('Diff image mean at different time integrations');
	subplot (224); grid;
	plot (diffstd, 'b*'); grid;
	xlabel ('Integrated time (secs)'); ylabel ('std. pixel value');
	title ('Diff image std. at different time integrations');

	x = [1:winsize/2];

	% The canonical thermal noise curve, x is in secs of integration time.
	y = x.^-0.5; 
	figure;
	loglog (x, y, 'k-');
	hold on;
	% NOTE: Normalizing with largest variance to match theoretical curve.
	loglog (x, rawstd/max(rawstd), 'r*-');
	loglog (x, diffstd/max(diffstd), 'b*-');
	grid;
	title ('Noise region std Vs. integration time');
	xlabel ('integration time(secs)');
	ylabel ('Normalized noise std.');
	legend ('Theoretical thermal', 'Raw image', 'Difference Image');

	% Generate images, differences and second differences.
%	for im = 2:winsize
%		% Get next ACM timeslice.
%		[acc, img.tobs, img.freq] = readms2float (fid, -1, 0, 288);
%
%		% Generate image and difference image.
%   		[radecmap, img.map, calvis, img.l, img.m] = ... 
%		  fft_imager_sjw_radec (acc(:), uloc(:), vloc(:), ... 
%					duv, Nuv, uvpad, img.tobs, img.freq, 0);
%
%		diffimg (:,:, im-1) = real(img.map) - real(prevmap);
%
%		% For pixel level running mean/var, generate integrated pixels.
%		sigdiff  = sigdiff  + diffimg (:,:,im-1); 
%		sigdiff2 = sigdiff2 + diffimg (:,:,im-1).^2;
%		mapsigdiff = mapsigdiff + img.map;
%		mapsigdiff2 = mapsigdiff2 + img.map.^2;
%
%		% Determine mean/var of cumulative RAW and DIFF image till now.
%		tmpreg = sigdiff (xbl:xtr, ybl:ytr)/(im-1); % The mean cumulative image.
%		cumuldiffmean(im) = mean (tmpreg(:));   % Get mean over chosen region.
%		cumuldiffvar (im) = std (tmpreg(:));    % Get std. over chosen region
%
%		tmpreg = mapsigdiff (xbl:xtr, ybl:ytr)/(im-1); % Now for the RAW image.
%		cumulmapmean(im) = mean (tmpreg(:));   % Get mean over chosen region.
%		cumulmapvar (im) = std (tmpreg(:));    % Get std. over chosen region
%
%		% Show input and difference images.
%		% figure (diffhdl);
%		% subplot (121);
%		% imagesc (diffimg (:,:,im-1).*mask); colorbar;
%
%		% Generate spatial noise stats over selected region, within the snapshot
%		% diff image noise
%		noisemap = diffimg (xbl:xtr, ybl:ytr, im-1);
%		meantseries (im) = mean (noisemap(:)); 
%		sigtseries  (im) = std  (noisemap(:));
%		% raw image noise
%		mapnoisereg = img.map (xbl:xtr, ybl:ytr);
%		meanmaptseries (im) = mean (mapnoisereg(:));
%		sigmaptseries  (im) = std  (mapnoisereg(:));
%
%%		noisemin = min (noisemap(:));  noisemax = max (noisemap(:));
%%		fprintf (1, ... 
%%		'[Min, Max, rng, mean, var] = %6.1f, %6.1f, %6.1f %6.3f, %6.1f\n', ...
%%				 noisemin, noisemax, noisemax-noisemin,  m, v);
%
%		% Print number of pixels above 3sigma in map, and their locations
%		% This can help check correspondence with sources;
%		outliermap = zeros (uvpad);
%		outliermap ((noisemap > thresh*sigtseries(im))) = 1;
%
%		% Show difference image and histogram over chosen region.
%		figure (diffhdl);
%		subplot (121); imagesc (diffimg (:,:,im-1).*mask); colorbar;
%		subplot (122); hist (noisemap(:), 100);
%
%		% Show raw image and histogram over chosen region.
%		figure (maphdl);
%		subplot (121); imagesc (img.map.*mask); colorbar;
%		subplot (122); hist (mapnoisereg(:), 100);
%		axis ('tight');
%
%		% imagesc (outliermap); colorbar;
%		prevmap = img.map;
%	end;

	
	% Figure management
	stathdl = figure;
	set(0,'Units','pixels') 
	scnsize = get(0,'ScreenSize');
	position = get(stathdl,'Position');
	outerpos = get(stathdl,'OuterPosition');
	borders = outerpos - position;
	edge = -borders(1)/2;
	% pos = [left bottom width height]
	pos1 = [edge, 0, scnsize(3)-edge, scnsize(4)];
	set(stathdl,'OuterPosition',pos1);

	subplot (221);
	imagesc (meanperpix); colorbar;
	xlabel ('X-Pixel'); ylabel ('Y-Pixel');
	title ('1-sec. DIFF image mean per pixel');
	subplot (222);
	imagesc (sigperpix); colorbar;
	xlabel ('X-Pixel'); ylabel ('Y-Pixel');
	title ('1-sec. DIFF image variance per pixel');
	subplot (223);
	imagesc (mapmeanperpix); colorbar;
	xlabel ('X-Pixel'); ylabel ('Y-Pixel');
	title ('RAW image mean per pixel');
	subplot (224);
	imagesc (mapsigperpix); colorbar;
	% caxis ([-50 100]);
	xlabel ('X-Pixel'); ylabel ('Y-Pixel');
	title ('RAW image variance per pixel');

%	% Print histogram of integrated raw image and diff image.
%	figure;
%	% Chosen region in integrated noise map.
%	noisemap = meanperpix (xbl:xtr, ybl:ytr); 
%	subplot (121);
%	hist (noisemap(:), 50);
%	xlabel ('Pixel value'); ylabel ('Counts');
%	title ('Integrated DIFF image histogram over chosen region');
%	mapnoisereg = mapmeanperpix (xbl:xtr, ybl:ytr);
%	subplot (122);
%	hist (mapnoisereg(:), 50);
%	xlabel ('Pixel value'); ylabel ('Counts');
%	title ('Integrated RAW image histogram over chosen region');
%	
%
	

	

	% Print number of pixels above 3sigma in map, and their locations
	% This can help check correspondence with sources;
	% TODO
