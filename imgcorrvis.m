% Script to generate stokes-I FITS images from GPU correlated visibilities available
% in a .vis file generated by the GPU correlator.

% Argument:
%    fname    : Array of filenames, one per subband, of binary .vis files.
%    obs        : Structure with observation related parameters. 
%             If parameters are not specified, the defaults present here are
%             used.
%        obs.npol    : Number of pols in input. [Default 2].
%        obs.nchan    : Number of chans in input.[Default 63].
%        obs.nelem    : Number of antenna elements in input.[Default 288].
%        obs.sub     : Subband number of each file.
%        obs.freq    : Freq of each subband, in Hz.
%        obs.stokes    : Stokes required (XX, YY, XY, YX, I, Q) [Default I].
%        obs.bwidth    : Spectral integration needed on observation. Specify as a
%                        range of subbands [start:skip:end] [Default all presented
%                        subbands].[UnImplemented]
%        obs.imgspectint: Bool indicating whether spectral integration should occur
%                         pre or post imaging [Default postimaging].
%        obs.fov        : FoV to image, in deg[Default 180, all-sky].
%        obs.skip    : Stride of time records to image. Set as a python range
%                      [start:skip:end, -1 for end] [Default skip none]
%                      [Unimplemented].
%        obs.flagant : Preflagging of antennas;
%    fout    : Output folder, which will contain the generated FITS image files
%              [Default same folder as that containing .vis files].

function [] = imgcorrvis (fname, obs, fout)

    % Validate the presence of the .vis file
    for i = 1:length (fname)
        assert (exist (fname{i}) == 2);
    end;
    nsub = length (fname);
    fprintf (2, '<-- Working with %d subbands.\n', nsub);
    
    % Setup the remainder of the obs structure, if uninitialized.
    if (isfield (obs, 'nchan' ) == 0) obs.nchan =  63; end;
    if (isfield (obs, 'chanwidth') == 0) obs.chanwidth =  3051.75; end;
    if (isfield (obs, 'chans' ) == 0) obs.chans =  [1:63]; end;
    if (isfield (obs, 'npol'  ) == 0) obs.npol  =   2; end;
    if (isfield (obs, 'nelem' ) == 0) obs.nelem = 288; end;
    if (isfield (obs, 'nbline') == 0) obs.nbline= 41616; end;
    if (isfield (obs, 'freqflag') == 0) obs.freqflag= 0; end;
    if (isfield (obs, 'skip'  ) == 0) obs.skip  =   0; end;
    if (isfield (obs, 'deb'   ) == 0) obs.deb   =   0; end;
    if (isfield (obs, 'stokes') == 0) obs.stokes=   0; end; % [XX=0,YY=1,XY=2,YX=3,I=4,Q=5]
    if (isfield (obs, 'fov'   ) == 0) obs.fov   = 180; end;
    if (isfield (obs, 'cal'   ) == 0) obs.cal   =   1; end;
    if (isfield (obs, 'ptSun' ) == 0) obs.ptSun =   1; end;
    if (isfield (obs, 'uvflag_x') == 0) obs.uvflag_x =   eye(obs.nelem); end;
    if (isfield (obs, 'uvflag_y') == 0) obs.uvflag_y =   eye(obs.nelem); end;
    if (isfield (obs, 'imgspectint') == 0) obs.imgspectint= 1; end;
    if (isfield (obs, 'bwidth') == 0) obs.bwidth= [1:nsub]; end;
    if (isfield (obs, 'flagant_x') == 0) obs.flagant_x = []; end; 
    if (isfield (obs, 'flagant_y') == 0) obs.flagant_y = []; end;
    if (isfield (obs, 'posfilename') == 0) obs.posfilename = 'poslocal_outer.mat'; end;
    if (isfield (obs, 'sub') == 0) 
        for i = 1:length (fname) obs.sub(i) = 294+i; end;
    end;
    if (isfield (obs, 'gridparm') == 0)
        obs.gridparm.type = 'pillbox';
        obs.gridparm.lim  = 0;

        % Control imaged field of view, independently of frequency.
        % obs.gridparm.duv  = (0.5/180)*obs.fov;
        obs.gridparm.duv  = 0.5;

        obs.gridparm.Nuv  = 1024;    % size of gridded visibility matrix
        obs.gridparm.uvpad= 1024;    % specifies if any padding needs to be added
        obs.gridparm.fft  = 1;
    end;

    % Local horizon based coordinates of array in ITRF
    load (obs.posfilename, 'posITRF', 'poslocal'); 

    % Generate uv coordinates in local horizon coord. system, needed for imaging
    uloc = meshgrid (poslocal(:,1)) - meshgrid (poslocal (:,1)).';
    vloc = meshgrid (poslocal(:,2)) - meshgrid (poslocal (:,2)).';

    [uloc_x, vloc_x] = gen_flagged_uvloc (uloc, vloc, obs.flagant_x);
    [uloc_y, vloc_y] = gen_flagged_uvloc (uloc, vloc, obs.flagant_y);

    % Generate a one time grid for frequency splatting.
    if (obs.imgspectint == 0)
         % Lowest frequency needs the highest resolution uv grid.
        [sortfreq, sortind] = sort (obs.sub);
        sortfreq = sortfreq * 195312.5;

        % Generate gridded vis. at the highest UV resolution
        uvlim = floor (obs.gridparm.Nuv/2)*obs.gridparm.duv;
        gridrng = linspace (-uvlim, uvlim, obs.gridparm.Nuv);
        paduvlim = floor (obs.gridparm.uvpad/2)*obs.gridparm.duv;
        padgridrng = linspace (-paduvlim, paduvlim, obs.gridparm.uvpad);
    
        % UV coordinates for all baselines, in lambda units.
        u = zeros (nsub, prod(size(uloc_x)));
        v = zeros (nsub, prod(size(vloc_x)));
        for sb = 1:nsub
            u(sb,:) = uloc_x(:)*sortfreq(sb)/299792458.;
            v(sb,:) = vloc_x(:)*sortfreq(sb)/299792458.;
        end;

        % Generate a single grid for all subbands.
        [uc, vc] = meshgrid (gridrng);
        uc = uc (:); vc = vc (:); % Vectorize the grid.
    end;

    for i = [1:nsub]
        obs.freq = obs.sub(i)*195312.5;
        fprintf (1, '<-- Creating VisRec object for file %s with freq %f.\n', fname{i}, obs.freq);
        sbrecobj (i) = VisRec(fname{i}, obs); 
    end;

    % Main loop handing the data.
    acm_x = zeros (nsub, obs.nelem, obs.nelem);
    acm_y = zeros (nsub, obs.nelem, obs.nelem);
    t1 = triu (ones (obs.nelem));
    while 1
    % for pep = 1:1
        for sb = 1:nsub
            try
                % Read in a single record. Data stored internally.
                sbrecobj(sb).readRec ([1,0,0,1], obs.chans);
            catch ME
                fprintf (2, 'Exception in reading record: %s', ME.message);
                break;
            end;            

            % Calibrate XX if stokes I or XX image is required
            if (obs.stokes >= 2 || obs.stokes == 0)
                % NOTE: readRec() already creates an average over channels!
                acm_tmp = zeros (obs.nelem);
                acm_tmp (t1 == 1) = sbrecobj(sb).xx;
                acm_tmp = acm_tmp + acm_tmp';
                acm_tmp (eye(obs.nelem) == 1) = real(diag(acm_tmp));
                acm_x(sb,:,:) = conj(acm_tmp);

                if (obs.cal == 1)
                    fprintf (2, '\n<-- Calibrating XX for subband %d.\n', sb);
                    sol_x(sb) = pelican_sunAteamsub (squeeze(acm_x(sb,:,:)), sbrecobj(sb).trecstart, sbrecobj(sb).freq, obs.uvflag_x, obs.flagant_x, obs.deb, obs.ptSun, [], [], obs.posfilename, [], []);
                    fprintf (1, '<-- Sigmas : %.5f\n', sol_x(sb).sigmas);
                end;
            end;

            % Calibrate YY if stokes I or YY image is required
            if (obs.stokes >= 2 || obs.stokes == 1)
                acm_tmp = zeros (obs.nelem);
                acm_tmp (t1 == 1) = sbrecobj(sb).yy;
                acm_tmp = acm_tmp + acm_tmp';
                acm_tmp (eye(obs.nelem) == 1) = real(diag(acm_tmp));
                acm_y(sb,:,:) = conj(acm_tmp);
                
                if (obs.cal == 1)
                    fprintf (2, '\n<-- Calibrating YY for subband %d.\n', sb);
                    sol_y(sb) = pelican_sunAteamsub (squeeze(acm_y(sb,:,:)), sbrecobj(sb).trecstart, sbrecobj(sb).freq, obs.uvflag_y, obs.flagant_y, obs.deb, obs.ptSun, [], [], obs.posfilename, [], []);
                    fprintf (1, '<-- Sigmas : %.5f\n', sol_y(sb).sigmas);
                end;
            end;

        end; % End of calibration loop over subbands

        % If requested, splat all visibilities on a common grid
        if (obs.imgspectint == 0)

	       % Handle a single subband
	       gridvis_x = zeros(obs.gridparm.Nuv);
	       gridvis_y = zeros(obs.gridparm.Nuv);
	       gridvis_xcnt = ones (obs.gridparm.Nuv);
	       gridvis_ycnt = ones (obs.gridparm.Nuv);
	       missed_vis = 0;   % cumulative count of ignored visibilities due to 
	                         % gridded value exeeding grid size.

            for sb = 1:nsub
                fprintf (2, '<-- Splatting subband %d.\n', obs.sub(sb));

                % XX pol
                if (obs.stokes >= 2 || obs.stokes == 0)
                    for idx = 1:length(uloc_x(:))            % For every recorded visibility
                    
                        % Get amp. and direction vector of visibility
                        ampl = abs(sol_x(sb).calvis(idx));            
                        phasor = sol_x(sb).calvis(idx) / ampl;
                    
                        % Determine the grid along U-axis in which observed visibility falls.
                        uidx = u(sb,idx) / obs.gridparm.duv + obs.gridparm.Nuv / 2;  
                        uidxl = floor(uidx);        % Find the lower and higher gridded U-value.
                        uidxh = ceil(uidx);
                    
                        % Find absolute distance of measured visibility from grid points, in the
                        % U-direction only.
                        dul = abs(uidx - uidxl);        
                        duh = abs(uidx - uidxh);
                    
                        % Distribute the visiblity amplitude among the two grid points on the 
                        % U-axis in proportion to their distance from the observed visiblity.
                        sul = duh * ampl;
                        suh = dul * ampl;
                        
                        % Determine the grid along V-axis in which observed visibility falls.
                        vidx = v(sb, idx) / obs.gridparm.duv + obs.gridparm.Nuv / 2;
                        vidxl = floor(vidx);        % Find the lower and higher gridded V-value.
                        vidxh = ceil(vidx);
                    
                        % Find absolute distance of measured visibility from grid points, in the
                        % V-direction only.
                        dvl = abs(vidx - vidxl);
                        dvh = abs(vidx - vidxh);
                    
                        % Distribute the HIGHER u-grid point's share of the observed visibility
                        % amp. between the higher and lower V-grid point.
                        sull = dvh * sul;
                        suhl = dvh * suh;
                    
                        % Distribute the LOWER u-grid point's share of the observed visibility 
                        % amp. between the higher and lower V-grid point.
                        sulh = dvl * sul;
                        suhh = dvl * suh;
                        
                        % Now that the observed visiblity amplitude is distributed among its 
                        % surrounding 4 grid points, fill the gridded visibility matrix with
                        % vectors with the same phase as the original observed visibility.
                        % NOTE: Adding the 4 vectors at the corners of the grid square will give
                        % back the original ungridded observed visibility.
                        % NOTE: We need to accumulate this to prevent overwriting the gridded 
                        % values from a visibility from a neighbouring grid square.
                        if ((uidxl < 1) || (uidxh < 1) || (uidxl > obs.gridparm.Nuv) || (uidxh > obs.gridparm.Nuv))
                            missed_vis = missed_vis + 1;
                            continue;
                        end;
                
                        if ((vidxl < 1) || (vidxh < 1) || (vidxl > obs.gridparm.Nuv) || (vidxh > obs.gridparm.Nuv))
                            missed_vis = missed_vis + 1;
                            continue;
                        end;
                
                        % Deal with the autocorrelations explicitly, else they are set to 0 and lost.
                        if (u(sb, idx) == 0 && v(sb, idx) == 0)
                            gridvis_x(uidx, vidx) = gridvis_x(uidx, vidx) + ampl;
                            continue;
                        end;
                            
                        gridvis_x(uidxl, vidxl) = gridvis_x(uidxl, vidxl) + sull * phasor;
                        gridvis_x(uidxl, vidxh) = gridvis_x(uidxl, vidxh) + sulh * phasor;
                        gridvis_x(uidxh, vidxl) = gridvis_x(uidxh, vidxl) + suhl * phasor;
                        gridvis_x(uidxh, vidxh) = gridvis_x(uidxh, vidxh) + suhh * phasor;
            

                        gridvis_xcnt(uidxl, vidxl) = gridvis_xcnt(uidxl, vidxl) + 1;
                        gridvis_xcnt(uidxl, vidxh) = gridvis_xcnt(uidxl, vidxh) + 1;
                        gridvis_xcnt(uidxh, vidxl) = gridvis_xcnt(uidxh, vidxl) + 1;
                        gridvis_xcnt(uidxh, vidxh) = gridvis_xcnt(uidxh, vidxh) + 1;        


                        %W(uidx, vidx) = W(uidx, vidx)
                        if (missed_vis > 0)
                             fprintf (2, 'Missed vis: %d\n', missed_vis); 
                        end;
    
                    end; % End of visibility loop

                end; % End of stokes condition

                % YY pol
                if (obs.stokes >= 2 || obs.stokes == 1)
                    for idx = 1:length(uloc_x(:))            % For every recorded visibility
                    
                        % Get amp. and direction vector of visibility
                        ampl = abs(sol_y(sb).calvis(idx));            
                        phasor = sol_y(sb).calvis(idx) / ampl;
                    
                        % Determine the grid along U-axis in which observed visibility falls.
                        uidx = u(sb, idx) / obs.gridparm.duv + obs.gridparm.Nuv / 2;  
                        uidxl = floor(uidx);        % Find the lower and higher gridded U-value.
                        uidxh = ceil(uidx);
                    
                        % Find absolute distance of measured visibility from grid points, in the
                        % U-direction only.
                        dul = abs(uidx - uidxl);        
                        duh = abs(uidx - uidxh);
                    
                        % Distribute the visiblity amplitude among the two grid points on the 
                        % U-axis in proportion to their distance from the observed visiblity.
                        sul = duh * ampl;
                        suh = dul * ampl;
                        
                        % Determine the grid along V-axis in which observed visibility falls.
                        vidx = v(sb, idx) / obs.gridparm.duv + obs.gridparm.Nuv / 2;
                        vidxl = floor(vidx);        % Find the lower and higher gridded V-value.
                        vidxh = ceil(vidx);
                    
                        % Find absolute distance of measured visibility from grid points, in the
                        % V-direction only.
                        dvl = abs(vidx - vidxl);
                        dvh = abs(vidx - vidxh);
                    
                        % Distribute the HIGHER u-grid point's share of the observed visibility
                        % amp. between the higher and lower V-grid point.
                        sull = dvh * sul;
                        suhl = dvh * suh;
                    
                        % Distribute the LOWER u-grid point's share of the observed visibility 
                        % amp. between the higher and lower V-grid point.
                        sulh = dvl * sul;
                        suhh = dvl * suh;
                        
                        % Now that the observed visiblity amplitude is distributed among its 
                        % surrounding 4 grid points, fill the gridded visibility matrix with
                        % vectors with the same phase as the original observed visibility.
                        % NOTE: Adding the 4 vectors at the corners of the grid square will give
                        % back the original ungridded observed visibility.
                        % NOTE: We need to accumulate this to prevent overwriting the gridded 
                        % values from a visibility from a neighbouring grid square.
                        if ((uidxl < 1) || (uidxh < 1) || (uidxl > obs.gridparm.Nuv) || (uidxh > obs.gridparm.Nuv))
                            missed_vis = missed_vis + 1;
                            continue;
                        end;
                
                        if ((vidxl < 1) || (vidxh < 1) || (vidxl > obs.gridparm.Nuv) || (vidxh > obs.gridparm.Nuv))
                            missed_vis = missed_vis + 1;
                            continue;
                        end;
                
                        % Deal with the autocorrelations explicitly, else they are set to 0 and lost.
                        if (u(sb, idx) == 0 && v(sb, idx) == 0)
                            gridvis_y(uidx, vidx) = gridvis_y(uidx, vidx) + ampl;
                            continue;
                        end;
                            
                        gridvis_y(uidxl, vidxl) = gridvis_y(uidxl, vidxl) + sull * phasor;
                        gridvis_y(uidxl, vidxh) = gridvis_y(uidxl, vidxh) + sulh * phasor;
                        gridvis_y(uidxh, vidxl) = gridvis_y(uidxh, vidxl) + suhl * phasor;
                        gridvis_y(uidxh, vidxh) = gridvis_y(uidxh, vidxh) + suhh * phasor;

                        gridvis_ycnt(uidxl, vidxl) = gridvis_ycnt(uidxl, vidxl) + 1;
                        gridvis_ycnt(uidxl, vidxh) = gridvis_ycnt(uidxl, vidxh) + 1;
                        gridvis_ycnt(uidxh, vidxl) = gridvis_ycnt(uidxh, vidxl) + 1;
                        gridvis_ycnt(uidxh, vidxh) = gridvis_ycnt(uidxh, vidxh) + 1;        


                        if (missed_vis > 0)
                          fprintf (2, 'Missed vis: %d\n', missed_vis); 
                        end;
    
                    end; % End of visibility loop

                end; % End of stokes condition
            
            end; % End of subband loop.

            % Uniform weighting
            % Calculate the average visibility, while accounting for
            % the number of visibilities in each grid cell.
            % gridvis_x = gridvis_x ./ gridvis_xcnt;
            % gridvis_y = gridvis_y ./ gridvis_ycnt;

            fprintf (1, '<-- Filled %d of %d gridpoints with %d subbands.\n', sum(gridvis_xcnt(:) ~= 1), length (gridvis_xcnt(:)), sb);

            dl = (1/(obs.gridparm.uvpad * obs.gridparm.duv)); % dimensionless, in dir. cos. units
            lmax = dl * obs.gridparm.uvpad/ 2;
            l = linspace (-lmax, lmax, obs.gridparm.uvpad);
            m = l;  % Identical resolution and extent along m-axis
            
            % Create a mask to mask out pixels beyond the unit circle (these are below 
            % the horizon.)
            mask = NaN (length(l));
            mask(meshgrid(l).^2 + meshgrid(l).'.^2 < 1) = 1;
            switch obs.stokes
                case 0
                    % Where do these NaNs come from??
                    gridvis_x (isnan(gridvis_x)) = 0;
                    gridvis_x = conj(flipud(fliplr(fftshift(gridvis_x))));
                    skymap_x = fftshift(fft2(gridvis_x));
                    integmap = single (real(skymap_x) .* mask)';

                case 1
                    % Where do these NaNs come from??
                    gridvis_y (isnan(gridvis_y)) = 0;
                    gridvis_y = conj(flipud(fliplr(fftshift(gridvis_y))));
                    skymap_y = fftshift(fft2(gridvis_y));
                    integmap = single (real(skymap_y) .* mask)';

                case 4
                    % Where do these NaNs come from??
                    gridvis_x (isnan(gridvis_x)) = 0;
                    gridvis_x = conj(flipud(fliplr(fftshift(gridvis_x))));
                    skymap_x = fftshift(fft2(gridvis_x));

                    % Where do these NaNs come from??
                    gridvis_y (isnan(gridvis_y)) = 0;
                    gridvis_y = conj(flipud(fliplr(fftshift(gridvis_y))));
                    skymap_y = fftshift(fft2(gridvis_y));
                    integmap = single (((real(skymap_x) + real(skymap_y))/2).* mask)';

                case 5
                    % Where do these NaNs come from??
                    gridvis_x (isnan(gridvis_x)) = 0;
                    gridvis_x = conj(flipud(fliplr(fftshift(gridvis_x))));
                    skymap_x = fftshift(fft2(gridvis_x));

                    % Where do these NaNs come from??
                    gridvis_y (isnan(gridvis_y)) = 0;
                    gridvis_y = conj(flipud(fliplr(fftshift(gridvis_y))));
                    skymap_y = fftshift(fft2(gridvis_y));
                    integmap = single (((real(skymap_x) - real(skymap_y))).* mask)';

                otherwise
                    fprintf (2, '### Stokes Case %d not implemented!\n', obs.stokes);
            end;

        else
            % Image each subband separately
            map_x = zeros (nsub, obs.gridparm.uvpad, obs.gridparm.uvpad);
            map_y = zeros (nsub, obs.gridparm.uvpad, obs.gridparm.uvpad);
            for sb = 1:nsub

                fprintf (1, '\n<-- Imaging subband %d...\n', obs.sub(sb));
                if (obs.stokes >= 2 || obs.stokes == 0)
                    if (obs.cal == 1)
                           [radecmap, map_x(sb,:,:), calvis(sb,:,:), l, m] = ... 
                          fft_imager_sjw_radec (sol_x(sb).calvis(:), uloc_x(:), vloc_x(:), ... 
                            obs.gridparm, [], [], sbrecobj(sb).trecstart, obs.sub(sb)*195312.5, 0);
                    else 
                           [radecmap, map_x(sb,:,:), calvis(sb,:,:), l, m] = ... 
                          fft_imager_sjw_radec (squeeze(acm_x(sb, :, :)), uloc(:), vloc(:), ... 
                            obs.gridparm, [], [], sbrecobj(sb).trecstart, obs.sub(sb)*195312.5, 0);
                    end;
                end;
    
                if (obs.stokes >= 2 || obs.stokes == 1)
                    if (obs.cal == 1)
                           [radecmap, map_y(sb,:,:), calvis(sb,:,:), l, m] = ... 
                             fft_imager_sjw_radec (sol_y(sb).calvis(:), uloc_y(:), vloc_y(:), ... 
                                obs.gridparm, [], [], sbrecobj(sb).trecstart, obs.sub(sb)*195312.5, 0);
                    else
                           [radecmap, map_y(sb,:,:), calvis(sb,:,:), l, m] = ... 
                             fft_imager_sjw_radec (squeeze(acm_y(sb,:,:)), uloc(:), vloc(:), ... 
                                obs.gridparm, [], [], sbrecobj(sb).trecstart, obs.sub(sb)*195312.5, 0);
                    end;
                end;

            end;

            switch obs.stokes
                case 0
                    integmap = squeeze (mean (map_x, 1));

                case 1
                    integmap = squeeze (mean (map_y, 1));

                case 4
                    integmap = squeeze (mean (map_x, 1) + mean (map_y,1))/2;

                case 5
                    integmap = squeeze (mean (map_x, 1) - mean (map_y,1));

                otherwise
                    fprintf (2, '### Case %d not implemented!\n', obs.stokes);
            end
        end % End of else imgspectcorr

        % Generate FITS filename for this final image
        img.tobs       = sbrecobj(1).trecstart;
        img.pix2laxis = size (integmap, 1);
        img.pix2maxis = size (integmap, 2);
        img.freq       = mean (obs.sub*195312.5);
        img.df        = nsub*length (obs.chans)*obs.chanwidth;

        % Generate map with pixel values ranging between 0 and 1
        % tmp = integmap - min(min(integmap)); % Bring it up to 0;
        % img.map       = tmp./max(max(tmp)); % Get values between 0 and 1;
        img.map = integmap;
        
        if (isempty (fout)) 
            fout = './'; 
        end;
        integmapname = sprintf ('%s/Sb%3d-%3d_R%02d-%02d_T%s.fits', fout, obs.sub(1), obs.sub(end), obs.chans(1), obs.chans(end), datestr (mjdsec2datenum (sbrecobj(1).trecstart), 'dd-mm-yyyy_HH-MM-SS')); 

        % Write out image as fits
        fprintf (1, '<-- Writing out %s\n', integmapname);
        try
            wrimg2fits (img, integmapname);
        catch ME
            throw (ME);
            break;
        end;

        if (obs.imgspectint == 0)
	        % Write out weightmap as a fits image
	        img.map = gridvis_xcnt; % X and Y counts should be the same due to the
	                                % same visibility coordinate
	
	        integmapname = sprintf ('%s/Sb%3d-%3d_R%02d-%02d_T%s_weight.fits', fout, obs.sub(1), obs.sub(end), obs.chans(1), obs.chans(end), datestr (mjdsec2datenum (sbrecobj(1).trecstart), 'dd-mm-yyyy_HH-MM-SS')); 
	
	        % Write out image as fits
	        fprintf (1, '<-- Writing out weights into %s\n', integmapname);
	        try
	            wrimg2fits (img, integmapname);
	        catch ME
	            throw ME;
	            break;
	        end;
        end;
    end % End of time dimension loop
end
