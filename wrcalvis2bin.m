% Program to read a .bin file (as generated by ms2float.py), calibrate each
% timeslice, and write out the result as another .bin file.
%
% Arguments:
% 	fname : Input .bin file containing uncalibrated visibilities
% 	offset: Offset in timeslices from the beginning of input file to start 
%		  	calibrating. 
%	ntslices: Number of timeslices to calibrate
%	wrcalsol: Bool turning on or off writing of calibration solutions to file.
%   trackcal: Bool turning off the application of tracking calibration. This
%			  results in te carrying out a o
%   array   : The array configuration, one of 'hba_dual', 'lba_inner', 
%			  'lba_outer'
% NOTE! NOTE: Currently, the list of antennas to be flagged is a parameter
%			  within the script, and needs to be changed for different datasets!
% pep/18Oct12

function wrcalvis2bin (fname, offset, ntslices, wrcalsol, trackcal, array)

%	gainplt = figure ;
%	currsolplt = figure ;
	Nelem = 288;
	badtimes = 0; % Statistics about the number of bad timeslices.
	badsols = 0; % Statistics about the number of bad solutions.
	nconvcals = 1; % No. of convcals to be done for reinit of tracking cal.

    % Necessary definitions
    uvflag = eye (Nelem); % Flag only the autocorrelations

	debuglev = 0;
	ptSun = 1;
	prevsol = [];

	% Window size for moving statistics.
	winsize = 10;
	solwinsize = 10; 
	medianthresh = 2.5; % Reject timeslices with median > medianthresh*movmed;
	visamphithresh= 1.5;% Reject visibilities with median >visampthresh*median.
	visamplothresh= 0.5;% Reject visibilities with median >visampthresh*median.
	solparm.solthresh=0.15;% Reject calsolutions with std. across antennas
						% in a station > solthresh percent from mean solutions.
	solparm.errthresh = 10; % Tolerance as offset from mean gainsol, in percent
	solparm.mse_ph_thresh = 0.1; % Radian
	% if (debuglev > 0)
		solparm.gainplt = figure;
		solparm.currsolplt = figure;
	% else
% 		solparm.gainplt = [];
% 		solparm.currsolplt =[];
% 	end;

	window = zeros (1, winsize); % Actual norm sliding window.

	% Cal. solution window size (One per ant, irrespective of current flagging.
	solwindow = complex (zeros (solwinsize, Nelem), zeros (solwinsize, Nelem)); 
	solwinfilled = 0;

	% Determine the array configuration to provide to pelican_sunAteamsub
	switch (array)
		case 'hba_dual'
			posfilename = 'poslocal_hba.mat';

		case 'lba_inner'
			posfilename = 'poslocal_inner.mat';

		case 'lba_outer'
			posfilename = 'poslocal_outer.mat';

		case 'lba_sparse'
			posfilename = 'poslocal_sparse.mat';

		otherwise
			error ('Unknown array configuration! Quitting...');
	end;

	% Determine number of timeslices to operate on
	if ntslices == -1
		[ntslices, tmin, tmax, dt] = getnrecs (fname);
		disp (sprintf ('Found %d records at %f sec. resolution.', ... 
				ntslices, dt));
		if (ntslices <= winsize)
			fprintf (2, 'wrcalvis2bin: Please specify number of timeslices larger than current window size (%d).', winsize);
			return ;
		end;
	end;

	% File handling section: Generate output filename
	k = strfind (fname, '.bin');
	if (trackcal == 1)
		outfname = [fname(1:k-1) '_' num2str(offset) '_trackcal.bin'];
	else
		outfname = [fname(1:k-1) '_' num2str(offset) '_convcal.bin'];
	end;
	fprintf (1, 'wrcalvis:Writing Calibrated visibilties to file : %s.',...
			 outfname);
	if wrcalsol == 1
		if (trackcal == 1)
			outsolfname = [fname(1:k-1) '_' num2str(offset) '_trackcalsol.bin'];
		else
			outsolfname = [fname(1:k-1) '_' num2str(offset) '_convcalsol.bin'];
		end;
		disp (['Writing Calibration solutions to file :' outsolfname]);
		if (exist (outsolfname, 'file') == 2)
			fprintf (2, 'Overwriting existing file: %s. Continue? (Ctrl-C to kill, any key to continue.)\n', outsolfname);
			pause;   % To prevent overwriting already written files!
		end;
		fsol = fopen (outsolfname, 'wb');
	end;
		
	fin = fopen (fname, 'rb');
	if (exist (outfname, 'file') == 2)
		fprintf (2, 'Overwriting existing file: %s. Continue? (Ctrl-C to kill, any key to continue.)\n', outfname);
		pause;   % To prevent overwriting already written files!
	end;
	fout = fopen (outfname, 'wb'); 
	[acc, t_obs, freq] = readms2float (fin, offset, -1, Nelem);
	if (isempty(acc) == true)
		disp ('wrcalvis2bin: Eof reached!');
		return;
	end;

	% Flagging section: Define antennas to flag.
	% For day-time observations over 3hr (2011 data)
    flagant = [6, 103];  

	% For LBA_INNER_BAND60 data
    % flagant = [1:12, 47, 48, 95,96, 143, 144, 191, 192, 239, 240, 287, 288 ];   
	% For LBA_OUTER_BAND60 data
    % flagant = [1:12, 51, 193, 239,273 ]; 

	% For LBA_OUTER_BAND_SPREAD data
    % flagant = [1:48, 51, 239]; 

	% For LBA_OUTER_BAND_SPREAD, 18min data
    % flagant = [51, 239, 273]; 
	
	% For 03285_dawn_spread data
    % flagant = [49:96, 239, 241:288]; 

	% For *_dawn_spread data (only 03285 has station 2 issues)
    % flagant = [51, 239, 240, 241:288]; 

	% For 24 Hr run on 20Nov13, r02
	% flagant = [129, 140, 149];

	% [uvflag, missant] = flagdeadcorr (acc, t_obs, freq, visamphithresh, ...
	%									visamplothresh);
	% flagant = unique ([flagant missant]);
	prevflagant = flagant;

	fprintf (2, 'NOTE! NOTE: Currently, the list of antennas to be flagged is a parameter within the script, and needs to be changed for different datasets!');


	% Print hardcoded parameters to console
	fprintf (2, '--> Norm Window size: %d\n', winsize);
	fprintf (2, '--> Solu Window size: %d\n', solwinsize);
	fprintf (2, '--> Median thresh (Time flagging):%f\n', medianthresh);
	fprintf (2, '--> Vis. ampl thresh range (Vis flagging):(%f, %f)\n', ...
			 visamphithresh,  visamplothresh);
	fprintf (2, '--> Solution phase thresh (Solu. flagging):%f\n', ... 
			 solparm.solthresh); 
	fprintf (2, '--> Default flagged antennas: %s\n', num2str(flagant));
	
	acc = single (acc);
   	antmask = zeros (size (acc));
	gainmask = zeros (1, size (acc,1));
    rem_ants = length(acc) - length(flagant);

	% Clear all persistent variables, which hold state across calls to 
	% wrcalvis2bin.m
	clear pelican_sunAteamsub;
	% Create a flagged mask for dealing with flagged antennas.
	disp (['## Flagging dipole numbers : ' num2str(flagant)]);
    for ind = 1:length(flagant)
    	antmask (flagant(ind), :) = 1; antmask (:,flagant(ind)) = 1;
    end
	gainmask (flagant) = 1;

	% Fill window for statistics
	for ind = 1:winsize
		[acc, t_obs, freq] = readms2float (fin, -1, -1, Nelem);
		acc (isnan(acc)) = 0; % NOTE NOTE! Norm fails if members are NaNs!
		window(ind) = norm (acc - diag(diag(acc)), 'fro');
		normts(ind) = window(ind);
	end;
	movmed = median (window);

	% NOTE: Not using an empty prevsol to pass onto tracking calib!
	% Update flagged visibilities
	[uvflag, missant] = flagdeadcorr (acc, t_obs, freq, visamphithresh, ...
										visamplothresh);
	currflagant = unique ([flagant missant]); % Not reshaping
	prevsol = pelican_sunAteamsub (acc, t_obs, freq, uvflag, ... 
						currflagant, debuglev, ptSun, [], [], posfilename, [], []);
    clear pelican_sunAteamsub;

	% Main loop iterating over timeslices. Functional parts:
	% - Carry out flagging over time window, also visibility flagging.
	% - Carry out conventional or tracking calibration per choice.
	% - Carry out a post calibration flagging.
	for ts = ind+1:ntslices
	 % try
		fprintf (1, '\n\n###### Working on Timeslice %d of %d.\n', ... 
			  ts+offset, offset+ntslices);
		[acc, t_obs, freq] = readms2float (fin, -1, -1, Nelem);
		if (isempty(acc) == true)
			fprintf (2, 'wrcalvis2bin: Eof reached!\n');
			return;
		end;
		acc = single (acc);
		acc (isnan(acc)) = 0; % NOTE NOTE! Norm fails if members are NaNs!

		% Check for bad timeslices.
		accnorm = norm (acc - diag(diag(acc)), 'fro'); % NOTE: Ignoring autocorr
		fprintf (1, 'Movmed: %f, accnorm: %f\n', movmed, accnorm);
		if ((accnorm > medianthresh*movmed) | (cond (acc) > 1e10))
			fprintf (2, '<--Discarding rec: %03d, Time: %.2f. Excess: %.2f\n', ...
				  ts, t_obs, accnorm/(medianthresh*movmed));
			badtimes = badtimes + 1;
			continue;
		end;

		% NOTE: Ignoring bad norm before the 'continue' as well!
		window (mod(ts,winsize) + 1) = accnorm; 
		movmed = median (window);

		% Update flagged visibilities
		[uvflag, missant] = flagdeadcorr (acc, t_obs, freq, visamphithresh, ...
										visamplothresh);
		currflagant = unique ([flagant missant]);
		gainmask = zeros (1, size (acc,1));
		gainmask (currflagant) = 1;
		if (length(currflagant) ~= length(prevflagant)) % Have to reshape the array.
   			antmask = zeros (size (acc));
			for ant = 1:length(currflagant)
    			antmask (currflagant(ant), :) = 1; antmask (:,currflagant(ant)) = 1;
    		end;
			gainmask = zeros (1, size (acc,1));
			gainmask (currflagant) = 1;
			prevflagant = currflagant;
		end;
		
		fprintf (1, 'Time: %f, freq: %f\n', t_obs, freq);
		currsol.tobs = t_obs;
		currsol.freq = freq;
		if (trackcal == 0)
	   	    currsol = pelican_sunAteamsub (acc, t_obs, freq, uvflag, ... 
				currflagant, debuglev, ptSun, [], [], posfilename, [], []);
		else %% Carry out a local, tracking calibration.
		%%% NOTE: Both cal_ext and gainsolv iterations are set to 1! NOTE!%%%
		%%% NOTE: gainsolv iters need to be set to 2 for averaging! NOTE%%% 
		% NOTE: If the number of antennas increases in the next timeslice, we 
		% need to fill the gains of prevsol with something other than 0, else
		% the matrices become ill-conditioned...
			if (length (prevsol.flagant) > length (currflagant))
				% Find out for which ants we need to generate gains.
				% These are the ants present in prevsol.flagant, but not in
				% currflagant. NOTE: setdiff is not commutative!
				newinitgainants = setdiff (prevsol.flagant, currflagant);

				% Search in solution window for the required initial estimates
				for win=1:solwinsize
					if (sum(solwindow (ind, newinitgainants)) ~= 0)
						break;
					end;
				end;

				% Populate prevsol.[gainsol, cal1, sigman] with gains, if found
				if (ind < solwinsize)
					prevsol.gainsol (newinitgainants) =  ...
												solwindow(ind, newinitgainants);
					% prevsol.sigman = zeros (length(prevsol.gainsol));
				else
					% If no gains are available, recalibrate from scratch.
					fprintf (2,'--> No prev gains. Calib. to convergence.\n');
	   	    		prevsol = pelican_sunAteamsub (acc, t_obs, freq, uvflag, ...
									currflagant, debuglev, ptSun, [], [], posfilename, [], []);
					nconvcals = nconvcals + 1;
				end;
			end;

	   	    currsol = pelican_tracking_cal (acc, t_obs, freq, uvflag, ... 
						currflagant, debuglev, ptSun, prevsol, 3, 4);
		end; 

		fprintf (1, 'wrcalvis:currsol calext (iter/pinv): %d, %f\n', ...
						currsol.calext_iters, currsol.pinv_sol);
		fprintf (1, 'wrcalvis:currsol gainsolv (iter/ tol): %d, %f\n', ...
						currsol.stefsol.iter, currsol.stefsol.tol);


		if (trackcal == 1)
		% Check generated solution over window of solutions for consistency
		% Vector comparison => any antenna breaking limits throws the sol. away
		% meansol = mean (abs(solwindow(:, gainmask==0)));
		% stdsol = std (abs(solwindow(:, gainmask==0)));
		meanresol = mean (abs(real(solwindow)));
		meanimsol = mean (abs(imag(solwindow)));
		stdresol  = std  (real(solwindow));
		stdimsol  = std  (imag(solwindow));
		fprintf (1, 'mean(re/im) = (%f/%f), std(re/im) = (%f/%f)\n', ...
				 meanresol (24), meanimsol(24), stdresol(24), stdimsol(24));
		if (solwinfilled == 0)
			% solwindow (mod(ts,solwinsize) + 1, gainmask == 0) = ...
			solwindow (mod(ts,solwinsize) + 1, :) = currsol.gainsol;
			if (ts > solwinsize+ind)
				solwinfilled = 1;
				fprintf (2, 'wrcalvis2bin: Solution window filled.\n');
			end;
%			figure (currsolplt);
%			subplot (1,2,1);
%			plot (abs(solwindow)');
%			subplot (1,2,2);
%			plot (angle(solwindow)');

		else % Window filled!
			solstat = goodcalsol (solwindow, solwinsize, currsol, gainmask, solparm, debuglev);	
%			meansol = mean(solwindow);
%
%			err = 100*sum(abs(meansol - currsol.gainsol)) / sum(abs(meansol));
%			% Compute per station gain variances
%			goodcal = 1;
%			for sta=0:5
%				sta_ind = [sta*48+1 : (sta+1)*48];
%				stat_std = std(currsol.gainsol (gainmask(sta_ind) == 0));
%				solwin_std = std (meansol (gainmask(sta_ind) == 0));
%				if ((stat_std  < solwin_std-solthresh*solwin_std) ||  ...
%				    (stat_std  > solwin_std+solthresh*solwin_std)) 
%					goodcal = 0;
%					break;
%				end;
%				stat_std_arr(sta+1) = stat_std;
%				solwin_std_arr(sta+1) = solwin_std;
%			end;
%			fprintf (2, 'stat std: %s\nmean std: %s\nRel. Err: %f, goodcal:%d\n', ...
%				 num2str(stat_std_arr), num2str(solwin_std_arr), err, goodcal);
			% if (goodcal == 1 && err < 10)
			if (solstat.goodstncal == 1) % Take solutions with offset
				% Update gain solution temporal window, if good solution.
				solwindow (mod(ts,solwinsize) + 1, :) = currsol.gainsol;
	
			% elseif (err > 10) % Handle a bad solution.
			else % (err > 10) % Handle a bad solution.
				fprintf (2, '-->Rejecting sol at rec %03d, tobs: %.2f\n', ...
						 ts+offset, currsol.tobs);

				% Try to do a calibration to convergence on this data.
				if (trackcal == 1) % Do so only for tracking calibration.
					fprintf (2, '   --> Calibrating to convergence\n');
					currsol = pelican_sunAteamsub (acc, t_obs, freq, uvflag, ...
									currflagant, debuglev, ptSun, [], [], posfilename, [], []);
					solstat = goodcalsol (solwindow, solwinsize, currsol, gainmask, ...
											solparm, debuglev);	

	%				figure (currsolplt);
	%				subplot (1,2,1);
	%				plot (abs(meansol), '-b');
	%				hold on;
	%				plot (abs(currsol.gainsol), '-r');
	%				hold off;
	%				subplot (1,2,2);
	%				plot (angle(meansol), '-b');
	%				hold on;
	%				plot (angle(currsol.gainsol), '-r');
	%				hold off;
	
					% Check if this solution is any better...
%					err=100*sum(abs(meansol - currsol.gainsol)) / sum(abs(meansol));
%					goodcal = 1;
%					for sta = 0:5
%						sta_ind = [sta*48+1 : (sta+1)*48];
%						stat_std = std(currsol.gainsol(gainmask(sta_ind)== 0));
%						solwin_std = std (meansol (gainmask(sta_ind) == 0));
%						if ((stat_std  < solwin_std - solthresh*solwin_std)||...
%						    (stat_std  > solwin_std + solthresh*solwin_std)) 
%							goodcal = 0;
%							break;
%						end;
%						stat_std_arr(sta+1) = stat_std;
%						solwin_std_arr(sta+1) = solwin_std;
%					end;
					fprintf (2, 'Rel err: %f, goodcal: %d\n',  ... 
							solstat.err, solstat.goodstncal);
				end;
	
				% Common block to tracking and convergent calibration.
				if (solstat.err > 10)
					% Could not find a good tracking or convergent cal sol.
					fprintf (2, '   --> Rejecting timeslice.\n');
					badtimes = badtimes + 1;
					% Use the mean gain solution as the output of this
					% timeslice. NOTE: sigman and sigmas are also suspect!
					% currsol.gainsol = meansol; % Don't do it now...
					continue;
				else
					nconvcals = nconvcals + 1;
					badsols = badsols + 1;
					solwindow (mod(ts,solwinsize) + 1, :) = currsol.gainsol;
				end;
			end;
		end;
		end; %% NOTE: Temporary condition to eliminate windowing from conv.cal.

		% pause;
		% Arbitrarily declaring bad if more than half the antennas show badness.
%	(sum(abs(real(currsol.gainsol))>(meanresol+solthresh*stdresol))>Nelem/2)...
% || (sum(abs(imag(currsol.gainsol))>(meanimsol+solthresh*stdimsol))>Nelem/2)
%			% Reject solution
%		    a = sum(real(currsol.gainsol) > (meanresol + solthresh*stdresol));
%			fprintf (2, '-->Rejecting sol at rec %03d, tobs: %.2f, sum: %d.\n', ...
%					 ts+offset, currsol.tobs, a);
%			fprintf (2, '   --> Calibrating to convergence.\n');
%			prevsol = pelican_sunAteamsub (acc, t_obs, freq, uvflag, ... 
%							currflagant, debuglev, ptSun, [], []);
%			nconvcals = nconvcals + 1;
%			if (debuglev > 0)
%				plotyy ([1:284], meansol+solthresh*stdsol, [1:284], ...
%						meansol-solthresh*stdsol);
%				hold on;
%				plot (angle(currsol.gainsol), '-ro');
%			end;
%			badsols = badsols + 1;
%			continue;
%		%    (abs(currsol.gainsol) < (meansol - solthresh*stdsol)))
%
%			% WHAT ABOUT CALIBRATED AND SOURCE SUBTRACTED VISIBILITIES??TODO
%			% Best might be to continue after storing solutions, and just 
%			% throw the data (and also the solutions?)

		
		% Reconstruct acc with calibrated vis. AND visibilities from flagged 
		% dipoles put in.
		% calvis = double (calvis);
		acc (antmask == 0) = currsol.calvis;

		% NOTE!NOTE!NOTE!THIS IS REQUIRED FOR wracm2bin TO FUNCTION CORRECTLY!
		acc (antmask == 1) = NaN; % Flagged visibilities get a NaN.
		% whos acc;
		wracm2bin (fout, acc, currflagant, t_obs, freq);
		if wrcalsol == 1
			wrcalsol2bin (fsol, currsol);
		end;

		% Update solutions with currently obtained tracking cal solution.
		prevsol = currsol; 
     % catch excep
%		disp ('Exception caught! Clean quitting...');
%		getReport (excep, 'basic');
%	    % fclose (fout); fclose (fin);	
%	 end;
	end;

	fprintf (2, '--> Total timeslices processed: %d\n', ntslices);
	fprintf (2, '--> Number of bad timeslices found: %d\n', badtimes);
	fprintf (2, '--> Number of bad solutions found: %d\n', badsols);
	fprintf (2, '--> Number of conv. calib done: %d\n', nconvcals);
	if (fin > 0) fclose (fin);  end;
	if (fout > 0) fclose (fout);  end;
	if wrcalsol == 1
		fclose (fsol);
	end;
