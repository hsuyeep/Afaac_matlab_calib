% Script to return a chosen timeslice from a .bin file generated by ms2float.py
% Either an offset, or an absolute time can be given, with the function 
% returning the ACM, MJD time (in secs), Freq (in Hz).
% NOTE: If recoffset=-1, implies return the next record, for any other 
% positive number, return the record with that number offset from beginning
% of file.
% Arguments:
%   fid      : fid of the binary data file.
%   recoffset: Offset (in units of records) of the desired timeslice.
%   rettime  : Time in MJD seconds of the desired timeslice.
%   Nelems   : Number of elements making up a record in the data file.
% Returns  :
%   acc      : The complex, Hermitean symmetric Array Correlation Matrix with 
%              autocorrelations removed,corresponding to chosen timeslice.
%   tobs     : Time of observation, in MJD seconds, as a double.
%   freq     : Frequency of observation, in Hz.
% NOTE: Autocorrelations are removed before returning the data!
% pep/01May12

function [acc, tobs, freqobs] = readms2float (fid, recoffset, rettime, Nelem)
	if (isempty(Nelem) == 1) 
		Nelem = 288; 
	end;

	nblines = Nelem * (Nelem + 1)/2; 
	tobs = 1; freqobs = 1;
	recsize = 8*(2+nblines); % Bytes, assumed double =8, float=4 bytes.

	% NOTE: Currently ms2float handles only one channel data
	if (recoffset > 0)
		if (fseek (fid, (recoffset-1)*recsize, 'bof') < 0)
			err = MException('readms2float:fseek OutOfRange', ...
        			'recoffset is outside expected range');	
			error ('readms2float: seek error!');
			throw (err);
		end;
		tobs = fread (fid, 1, 'double');
		if (isempty (tobs) == true)
 			disp ('readms2float: EoF reached!'); 
			acc = []; tobs = []; freqobs = [];
			return;
		end;
	    freqobs = fread (fid, 1, 'double');
        % Reading real and imaginary, available as a stream of floats.
        % even floats being real parts, odd floats being imag
		a  = fread (fid, 2*nblines, 'float'); % Read one ccm worth
		disp (['Time at offset ', num2str(recoffset), ' recs: ', ...
			  num2str(tobs)]);
	elseif (recoffset == -1) % Return next record
		tobs = fread (fid, 1, 'double');
		if (isempty (tobs) == true)
 			disp ('readms2float: EoF reached!'); 
			acc = []; tobs = []; freqobs = [];
			return;
		end;
	    freqobs = fread (fid, 1, 'double');
		a  = fread (fid, 2*nblines, 'float'); % Read one ccm worth
		% disp (['Time: ', num2str(tobs), ' Freq: ', num2str(freqobs)]);
	end	

%	else if (recoffset < 0 && rettime > 0)
%		tobs1 = fread (fid, 1, 'double');
%	        freqobs = fread (fid, 1, 'double');
%		a = fread (fid, 2*nblines, 'float'); % Read one ccm worth
%		tobs2 = fread (fid, 1, 'double');
%		dt = tobs2 - tobs1;			
%		recs2time = int32 ((rettime - tobs1)/dt);
%		fseek (fid, 0, -1);
%		for recs = 1:recs2time
%		  tobs = fread (fid, 1, 'double');
%	          freqobs = fread (fid, 1, 'double');
%		  a = fread (fid, 2*nblines, 'float'); % Read one ccm worth
%		end
%		tobs = fread (fid, 1, 'double');
%	        freqobs = fread (fid, 1, 'double');
%		a = fread (fid, 2*nblines, 'float'); % Read one ccm worth
%		disp (['Found closest time to ', num2str(rettime), ':', num2str(tobs), ' at offset:', num2str(recs2time)]);
%	end

    comp = complex (a(1:2:length(a)), a(2:2:length(a))); % to complex

    % create instantaneous ccm from vector
    acm = triu (ones (Nelem));
    acm (acm == 1) = comp;

    % Removing autocorrelations
    acc = acm + acm' - diag(diag(acm));
	%fclose (fid);
end
