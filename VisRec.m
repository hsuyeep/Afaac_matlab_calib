% Class to handle records from binary .vis files, as generated by the GPU correlator.
% pep/03Feb16

classdef RecDat
	% Class representing a self contained visibility record.
	% Generated as an output of VisRec.readRec();
	properties
		nchan      = 0;
		npol	   = 0;
		nelem      = 0;
		freq       = 0;
		trecstart  = 0;
		trecend    = 0;
		dt		   = 0;
		xx         = []; % vector containing XX pol. data
		yy         = []; % vector containing XX pol. data
		xy         = []; % vector containing XY pol. data
		yx         = []; % vector containing YX pol. data
	end;
end;
	
classdef VisRec < handle 
	% Class to abstract access to visibilities generated by the GPU correlator.
	% Supports the different polarizations, channels, antenna combinations
	% possible, represents a single timeslice of data.
	properties
		nchan       = 0;  % Number of channels in this record
		npol		= 0;  % Number of polarizations
		nelem	    = 0;  % Number of antenna elements
		freq		= 0;  % Frequency of the subband of this visibility set.
		fname		= []; % Filename of file containing data
		fid			= 0;  % fid of file.
		currec		= 0;  % Current record number in the binary file.
		tfilestart  = 0;  % Timestamp of first record in binary file.
		tfileend	= 0;  % Timestamp of last record in binary file.
		skip		= 0;  % Number of records to skip while reading data.
		deb			= 0;  % Debug level, for verbosity of messages.

	end; % End of properties.

	methods 

		% Constructor
		% Opens the binary file, initializes internal variables.
		% If metainfo. cannot be determined from the data stream,
		% uses the externally supplied values.
		function  obj = VisRec (obj, fname, freq)
			assert (exist (fname) == 0);
			obj.fname = fname;
			try:
				obj.fid  = fopen (obj.fname, 'rb');	
			catch:
				fprintf (2, '### Error in opening file %s.\n', obj.fname);
			end;
						
			obj.freq = freq;
			obj.recdat = RecDat(); % Self contained data structure to hold a single records' data.
			obj.getVisMeta (); % Initialize internal data based on input data.
		end;

		% Destructor
		function delete (obj)
			if (obj.fid > 0)
				fclose (obj.fid);
			end;
		end;

		% Examine data stream, generate metadata structure.
		% Called only once to initialize internal data.
		% Arguments:
		%	info	: Structure containing the preinitalized parameters of this
		%			  observation. Note: raw visibility header contains only the
		%			  magic, start and end times, nothing more!
		function info = getVisMeta (obj, info)
			fprintf (1, '<-- Generating observation scan visibility meta data...\n');
			assert (obj.fid > 0);
			hdr = fread (obj.fid, 512, 'uint8');
			meta = obj.interprethdr (hdr);
			if (meta.magic == 0x)
				fprintf (1, '<-- Found Magic number %x in first record.\n',meta.magic);		
				obj.tfilestart = meta.tstart;
				fprintf (1, '<-- First record start time: %s.\n', datestr (mjdsec2datenum(obj.tfilestart)));
				obj.nchan = info.nchan;
				obj.nelem = info.nelem;
				obj.npol  = info.npol;
				obj.freq  = info.freq;
				% In units of floats, the native output datatype of the
				% correlator.
				obj.datfloatsize = 2*obj.npol*obj.nchan*obj.nelem*(obj.nelem+1)/2; 
				obj.recbytesize = 512 + obj.recbytesize*4; % Note: In bytes
			end;
		
			% Move to end of the file to obtain last record.
			fseek (obj.fid, -obj.recbytesize, 'eof');
			hdr = fread (obj.fid, 512, 'uint8'); % Read in hdr of the last record.
			meta = obj.interprethdr (hdr);
			if (meta.magic == 0x)
				fprintf (1, '<-- Found Magic number in last record. %x\n', meta.magic);		
				obj.tfileend = meta.tstart;
				fprintf (1, '<-- Last record start time: %s.\n', datestr(mjdsec2datenum(obj.tfileend)));		
			end;
			fseek (obj.fid, 'bof'); % Move tp the beginning of the file for further operations.
		end;
		
		% Function interprets the binary header and returns meta information.
		% Arguments:
		%	hdr : array of 512 uint8, corresponding to the first 512 bytes of
		%		  the visibility record.
		% Returns :
		%	meta: A structure containing metadata as extracted from the header.
		function meta = interpretHdr (obj, hdr)
			% Set the object magic value
			meta.magic  = typecast (hdr(1:4), 'uint32');
			meta.tstart = typecast (hdr(9:16), 'double');
			meta.tend   = typecast (hdr(17:24), 'double');

			return meta;
		end;

		% Arguments:
		%	pol  : The pols to  be read in. Bool array, [XX, XY, YX, YY]	
		%	chans: The channel subset to  be read in. Range [1:obj.nchans]	
		% Returns:
		%	dat : structure containg the actual data vectors for XX and YY pols, and
		%		  metadata.
		function dat = readRec(obj, pol, chans)
			assert (obj.fid > 0);
			hdr = fread (obj.fid, 512, 'uint8');

			% Interpret the header of this data record. Hdr is first 512 bytes.
			meta = obj.interpretHdr (hdr);
			
			assert (length (chans) < meta.nchans);

			% Update internal state variables of this record
			
			obj.recdat.nchan  = obj.nchan;
			obj.recdat.npol   = obj.npol;
			obj.recdat.nelem  = obj.nelem;
			obj.recdat.freq   = obj.freq;
			obj.recdat.trecstart = meta.tstart;
			obj.recdat.trecend   = meta.tend;
			obj.recdat.dt = meta.tend - meta.tstart;

			dat = fread (obj.fid, obj.datsize, [obj.nbline, obj.nchan, obj.npol, 2], 'single');
			% Fill in the RecDat object with desired channels and pols.
			% The fastest index in the linear float data array is nbline, nchan,
			% npol, re/im
			if (pols(1)) 
				obj.recdat.xx = complex (squeeze(dat(:,chans,1,1)), squeeze(dat(:,chans,1,2)));
			end;
			if (pols(4)) 
				obj.recdat.yy = complex (squeeze(dat(:,chans,2,1)), squeeze(dat(:,chans,2,2)));
			end;
			% NOTE: Ignoring XY and YX pols for now.
		end;
			
	end; % End of methods

end; % End of classdef
