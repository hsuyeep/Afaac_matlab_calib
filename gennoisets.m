% Script to generate a noise timeseries, given an image timeseries. Functions
% by creating a snapshot difference image, removing outliers , then computing
% medians after dividing the image into the specified number of concentric 
% rings.
% pep/16Jul13
% Arguments:
%	fname : Name of file containing binary images, as generated by wrimg2bin.
%	nreg : Number of regions to subdivide the all-sky image into.
% Returns:
%  noise: nreg x nrecs matrix containing the noise timeseries

function noise = gennoisets (fname, nreg, nrecs)
	if (isempty (fname))
		error ('Need a filename!\n');
	end;

	fid = fopen (fname, 'rb');
	if (fid < 0)
		disp ('showbinimages: fid < 0! Quitting.');
		return;
	end;

	% Read initial image in
	previmg = readimg2bin (fid);

	if (nrecs < 0)
		fdir = dir (fname);
		filesize = fdir.bytes;
		imgwhos = whos ('previmg');
		imgsize = imgwhos.bytes;
		nrecs = filesize/imgsize;
	end;

	noise = zeros (nreg, nrecs);
	mask = zeros (nreg, size (previmg.map,1), size (previmg.map,2));
	[lmesh, mmesh] = meshgrid (previmg.l, previmg.m);
	dr = 1/nreg;

	% Generate masks for concentric rings
	if (nreg == 1) % full image!
		mask (1, (lmesh.^2 + mmesh.^2 < 1)) = 1;
	else
		for ind = 1:nreg
			mask (ind, (lmesh.^2 + mmesh.^2) < ind*dr) = 1;
			mask (ind, (lmesh.^2 + mmesh.^2) <(ind-1)*dr) = 0;
		end;
	end;
	
	% Generate row and column numbers for the largest square within the all-sky
	% circle. We operate on this subimage for PSD computation.
	[r c] = size (previmg.map); % Get size of image.
	rtop = round (c/2*(1-1/sqrt(2))); % rad= cols/2, rtop = topleft. corner
	rbot = rtop+round (c/sqrt(2));    % rbot = row of bottom left corner.

	figure;
	for ts = 2:nrecs
		img = readimg2bin (fid);
		fprintf (1, 'Rec: %03d , %.2f, %.2f\n', ts, img.tobs, img.freq);
		diffimg = img.map - previmg.map;

		% Generate noise values within different regions
		for ind = 1:nreg
			imgreg = diffimg (mask (ind,:,:) == 1);
			noise (ind, ts) = std (imgreg);
		end;

		% Generate noise PSD: Weiner-Khintchin theorem (F.T of autocorr = PSD)
		subimg = diffimg (rtop:rbot, rtop:rbot);
		subimg (isnan(subimg)) = 0;
		subimgfft = fft2 (subimg);
		psd = fftshift ((subimgfft .* conj (subimgfft)));
		imagesc (20*log10(abs(psd)));
		pause (0.1);

		previmg = img;
	end;

    col = {'b*-', 'm*-', 'r*-', 'k*-', 'g*-', 'y*-', 'w*-', 'c*-'};
	leg_str = cell (1, nreg);
	for ind = 1:nreg
        leg_str {ind} = sprintf ('%.2f<r<%.2f\n',(ind-1)*dr, ind*dr); 
    end;
	for ind = 1:nreg
		plot ([2:nrecs], noise (ind, 2:end), char(col(ind)));
		hold on;
	end;
	title ('Noise distribution in difference image rings');
	xlabel ('Timeslices');
	ylabel ('Noise std (counts)');
	legend (leg_str);
